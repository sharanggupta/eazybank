# =============================================================================
# Smart Version Calculator (Reusable Workflow)
# =============================================================================
#
# Calculates semantic version for a service based on:
# 1. Latest git tag (source of truth)
# 2. Commits since that tag
# 3. Conventional commit message analysis
#
# Input: service name (account, card, loan, gateway)
# Output:
#   - new_version: e.g., "0.1.2"
#   - git_tag: e.g., "v-account-0.1.2"
#   - should_build: true/false (skip if only docs changed)
#
# =============================================================================

name: Calculate Service Version

on:
  workflow_call:
    inputs:
      service:
        description: 'Service name (account|card|loan|gateway)'
        required: true
        type: string
    outputs:
      new_version:
        description: 'New semantic version (e.g., 0.1.2)'
        value: ${{ jobs.calculate.outputs.new_version }}
      git_tag:
        description: 'Git tag name (e.g., v-account-0.1.2)'
        value: ${{ jobs.calculate.outputs.git_tag }}
      should_build:
        description: 'Whether to build this service (true/false)'
        value: ${{ jobs.calculate.outputs.should_build }}
      version_bump_type:
        description: 'Bump type applied (MAJOR|MINOR|PATCH|NONE)'
        value: ${{ jobs.calculate.outputs.version_bump_type }}

jobs:
  calculate:
    name: Calculate Version for ${{ inputs.service }}
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      git_tag: ${{ steps.version.outputs.git_tag }}
      should_build: ${{ steps.version.outputs.should_build }}
      version_bump_type: ${{ steps.version.outputs.version_bump_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate version
        id: version
        run: |
          SERVICE="${{ inputs.service }}"

          # =================================================================
          # Step 1: Determine if service code changed
          # =================================================================
          echo "ðŸ” Checking if $SERVICE code changed..."

          # Get list of changed files
          CHANGED_FILES=$(git diff HEAD~1 --name-only 2>/dev/null || echo "")

          # Check if any files in service directory changed (excluding docs)
          SERVICE_CHANGED=false
          if [ -z "$CHANGED_FILES" ]; then
            # First commit or no previous commit, check staged files
            SERVICE_CHANGED=$(git diff --name-only --cached | grep -E "^$SERVICE/" > /dev/null && echo "true" || echo "false")
          else
            SERVICE_CHANGED=$(echo "$CHANGED_FILES" | grep -E "^($SERVICE/|deploy/helm/services/$SERVICE/)" > /dev/null && echo "true" || echo "false")
          fi

          if [ "$SERVICE_CHANGED" != "true" ]; then
            echo "â„¹ï¸  No code changes for $SERVICE (docs/config only)"
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "version_bump_type=NONE" >> $GITHUB_OUTPUT
            echo "new_version=" >> $GITHUB_OUTPUT
            echo "git_tag=" >> $GITHUB_OUTPUT

            echo "### â­ï¸ Build Skipped for $SERVICE" >> $GITHUB_STEP_SUMMARY
            echo "No code changes detected (docs/config only changes)" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # =================================================================
          # Step 2: Get current version from git tags
          # =================================================================
          echo "ðŸ“ Getting current version from git tags..."

          # Find latest tag for this service
          LATEST_TAG=$(git describe --tags --match "v-${SERVICE}-*" --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "  â„¹ï¸  No previous tags found, starting at 0.0.0"
            CURRENT_VERSION="0.0.0"
            CURRENT_MAJOR=0
            CURRENT_MINOR=0
            CURRENT_PATCH=0
          else
            echo "  âœ“ Latest tag: $LATEST_TAG"
            # Extract version from tag (v-service-X.Y.Z)
            VERSION_STRING=$(echo "$LATEST_TAG" | sed "s/v-${SERVICE}-//")
            CURRENT_MAJOR=$(echo "$VERSION_STRING" | cut -d. -f1)
            CURRENT_MINOR=$(echo "$VERSION_STRING" | cut -d. -f2)
            CURRENT_PATCH=$(echo "$VERSION_STRING" | cut -d. -f3)
            CURRENT_VERSION="${CURRENT_MAJOR}.${CURRENT_MINOR}.${CURRENT_PATCH}"
          fi

          echo "  Current version: $CURRENT_VERSION"

          # =================================================================
          # Step 3: Analyze commits since last tag
          # =================================================================
          echo "ðŸ“‹ Analyzing commits..."

          # Get commits since last tag that touch this service
          if [ -z "$LATEST_TAG" ]; then
            # No tags yet: only check current commit (HEAD) to avoid looking at old history
            COMMITS=$(git log -1 --oneline HEAD -- "$SERVICE/" "deploy/helm/services/$SERVICE/" 2>/dev/null || git log -1 --oneline HEAD -- "$SERVICE/")
          else
            # Has tags: check commits since last tag
            COMMITS=$(git log "${LATEST_TAG}..HEAD" --oneline -- "$SERVICE/" "deploy/helm/services/$SERVICE/" 2>/dev/null || git log "${LATEST_TAG}..HEAD" --oneline -- "$SERVICE/")
          fi

          if [ -z "$COMMITS" ]; then
            echo "  â„¹ï¸  No commits since last tag"
            BUMP_TYPE="NONE"
          else
            echo "  Found commits:"
            echo "$COMMITS" | sed 's/^/    /'

            # =================================================================
            # Step 4: Determine version bump based on commit messages
            # =================================================================
            # Check for BREAKING CHANGE (highest priority)
            if echo "$COMMITS" | grep -iE "BREAKING CHANGE|[a-z]+!:" > /dev/null; then
              echo "  ðŸ”´ Found BREAKING CHANGE â†’ MAJOR bump"
              BUMP_TYPE="MAJOR"
            # Check for feat: (MINOR)
            elif echo "$COMMITS" | grep "feat:" > /dev/null; then
              echo "  ðŸŸ¡ Found feat â†’ MINOR bump"
              BUMP_TYPE="MINOR"
            # Check for fix/refactor/perf (PATCH)
            elif echo "$COMMITS" | grep -E "(fix|refactor|perf):" > /dev/null; then
              echo "  ðŸŸ¢ Found fix/refactor/perf â†’ PATCH bump"
              BUMP_TYPE="PATCH"
            # Default to PATCH if no recognized prefix
            else
              echo "  ðŸŸ¢ No recognized prefix â†’ PATCH bump (default)"
              BUMP_TYPE="PATCH"
            fi
          fi

          # =================================================================
          # Step 5: Calculate new version
          # =================================================================
          echo "ðŸ”¢ Calculating new version..."

          case $BUMP_TYPE in
            MAJOR)
              NEW_MAJOR=$((CURRENT_MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            MINOR)
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$((CURRENT_MINOR + 1))
              NEW_PATCH=0
              ;;
            PATCH)
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$CURRENT_MINOR
              NEW_PATCH=$((CURRENT_PATCH + 1))
              ;;
            NONE)
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$CURRENT_MINOR
              NEW_PATCH=$CURRENT_PATCH
              ;;
          esac

          NEW_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          GIT_TAG="${SERVICE}-v${NEW_VERSION}"

          # =================================================================
          # Step 6: Output results
          # =================================================================
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“Š Version Calculation Results"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Service:       $SERVICE"
          echo "Current:       $CURRENT_VERSION"
          echo "Bump Type:     $BUMP_TYPE"
          echo "New Version:   $NEW_VERSION"
          echo "Git Tag:       $GIT_TAG"
          echo "Should Build:  true"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Set outputs
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
          echo "should_build=true" >> $GITHUB_OUTPUT
          echo "version_bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

          # Add nice summary to GitHub Actions UI
          echo "### ðŸ“Š Version Calculation for $SERVICE" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Current Version** | \`$CURRENT_VERSION\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Bump Type** | \`$BUMP_TYPE\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **New Version** | \`$NEW_VERSION\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Git Tag** | \`$GIT_TAG\` |" >> $GITHUB_STEP_SUMMARY
